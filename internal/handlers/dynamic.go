package handlers

import (
	"bytes"
	"context"
	"fmt"
	"net/http"
	"strings"
	"text/template"

	"github.com/isoboot/isoboot/internal/k8s"
)

type DynamicHandler struct {
	host      string
	port      string
	proxyPort string
	k8sClient *k8s.Client
}

func NewDynamicHandler(host, port, proxyPort string, k8sClient *k8s.Client) *DynamicHandler {
	return &DynamicHandler{
		host:      host,
		port:      port,
		proxyPort: proxyPort,
		k8sClient: k8sClient,
	}
}

// PreseedData is passed to preseed templates
type PreseedData struct {
	Host      string
	Port      string
	ProxyPort string
	ProxyURL  string
	MAC       string
	MACColon  string
	Target    string
}

var debianPreseedTemplate = `# Debian Preseed Configuration
# Generated by isoboot for MAC: {{.MAC}}

# Localization
d-i debian-installer/locale string en_US.UTF-8
d-i keyboard-configuration/xkb-keymap select us

# Network
d-i netcfg/choose_interface select auto
d-i netcfg/disable_autoconfig boolean false

# Mirror
d-i mirror/country string manual
d-i mirror/http/hostname string deb.debian.org
d-i mirror/http/directory string /debian
d-i mirror/http/proxy string {{.ProxyURL}}

# Clock
d-i clock-setup/utc boolean true
d-i time/zone string UTC
d-i clock-setup/ntp boolean true

# Partitioning - use entire disk
d-i partman-auto/method string regular
d-i partman-auto/choose_recipe select atomic
d-i partman-partitioning/confirm_write_new_label boolean true
d-i partman/choose_partition select finish
d-i partman/confirm boolean true
d-i partman/confirm_nooverwrite boolean true

# User setup
d-i passwd/root-login boolean false
d-i passwd/user-fullname string Debian User
d-i passwd/username string debian
d-i passwd/user-password-crypted string $6$rounds=4096$randomsalt$hashedpassword

# Package selection
tasksel tasksel/first multiselect standard, ssh-server
d-i pkgsel/include string curl wget vim

# Boot loader
d-i grub-installer/only_debian boolean true
d-i grub-installer/bootdev string default

# Finish
d-i finish-install/reboot_in_progress note

# Late command - notify isoboot that install is complete
d-i preseed/late_command string \
    in-target curl -X POST "http://{{.Host}}:{{.Port}}/api/deploy/{{.MAC}}/complete" || true
`

// ServePreseed serves preseed configuration files
// Path format: /dynamic/{mac}/{target}/preseed.cfg
// Always returns 200 with Content-Length (empty if no deploy found)
func (h *DynamicHandler) ServePreseed(w http.ResponseWriter, r *http.Request) {
	// Parse path: /dynamic/xx-xx-xx-xx-xx-xx/debian-13/preseed.cfg
	path := strings.TrimPrefix(r.URL.Path, "/dynamic/")
	parts := strings.Split(path, "/")
	if len(parts) < 3 {
		w.Header().Set("Content-Type", "text/plain")
		w.Header().Set("Content-Length", "0")
		w.WriteHeader(http.StatusOK)
		return
	}

	mac := parts[0]
	target := parts[1]
	// parts[2] should be preseed.cfg

	// Validate MAC format (dash-separated from iPXE)
	mac = strings.ToLower(mac)
	macColon := strings.ReplaceAll(mac, "-", ":")

	// Verify deploy exists - return empty 200 if not found
	deploy, err := h.k8sClient.FindDeployByMAC(context.Background(), macColon)
	if err != nil || deploy == nil {
		w.Header().Set("Content-Type", "text/plain")
		w.Header().Set("Content-Length", "0")
		w.WriteHeader(http.StatusOK)
		return
	}

	// Verify target matches - return empty 200 if mismatch
	if deploy.Spec.Target != target {
		w.Header().Set("Content-Type", "text/plain")
		w.Header().Set("Content-Length", "0")
		w.WriteHeader(http.StatusOK)
		return
	}

	// Generate preseed based on target
	var tmpl *template.Template
	switch target {
	case "debian-13":
		tmpl = template.Must(template.New("preseed").Parse(debianPreseedTemplate))
	default:
		w.Header().Set("Content-Type", "text/plain")
		w.Header().Set("Content-Length", "0")
		w.WriteHeader(http.StatusOK)
		return
	}

	data := PreseedData{
		Host:      h.host,
		Port:      h.port,
		ProxyPort: h.proxyPort,
		ProxyURL:  fmt.Sprintf("http://%s:%s", h.host, h.proxyPort),
		MAC:       mac,
		MACColon:  macColon,
		Target:    target,
	}

	// Render to buffer first to get Content-Length
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		w.Header().Set("Content-Type", "text/plain")
		w.Header().Set("Content-Length", "0")
		w.WriteHeader(http.StatusOK)
		return
	}

	w.Header().Set("Content-Type", "text/plain")
	w.Header().Set("Content-Length", fmt.Sprintf("%d", buf.Len()))
	w.WriteHeader(http.StatusOK)
	w.Write(buf.Bytes())
}

// CompleteDeployment marks a deployment as completed
func (h *DynamicHandler) CompleteDeployment(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		w.Header().Set("Content-Length", "0")
		w.WriteHeader(http.StatusMethodNotAllowed)
		return
	}

	// Parse path: /api/deploy/{mac}/complete
	path := strings.TrimPrefix(r.URL.Path, "/api/deploy/")
	parts := strings.Split(path, "/")
	if len(parts) < 2 || parts[1] != "complete" {
		w.Header().Set("Content-Length", "0")
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	mac := strings.ToLower(parts[0])
	macColon := strings.ReplaceAll(mac, "-", ":")

	deploy, err := h.k8sClient.FindDeployByMAC(context.Background(), macColon)
	if err != nil || deploy == nil {
		w.Header().Set("Content-Length", "0")
		w.WriteHeader(http.StatusOK)
		return
	}

	if err := h.k8sClient.UpdateDeployStatus(context.Background(), deploy.Name, "Completed", "Installation completed"); err != nil {
		w.Header().Set("Content-Length", "0")
		w.WriteHeader(http.StatusOK)
		return
	}

	body := []byte("OK")
	w.Header().Set("Content-Length", fmt.Sprintf("%d", len(body)))
	w.WriteHeader(http.StatusOK)
	w.Write(body)
}

// RegisterRoutes registers dynamic content routes
func (h *DynamicHandler) RegisterRoutes(mux *http.ServeMux) {
	mux.HandleFunc("/dynamic/", h.ServePreseed)
	mux.HandleFunc("/api/deploy/", h.CompleteDeployment)
}
