set -eu
apk add --no-cache wget
{{- $tasks := .Tasks }}
{{- range $i, $t := $tasks }}
if [ ! -f '{{ $t.OutputPath }}' ]; then
  mkdir -p '{{ $t.OutputDir }}'
  echo '{{ $t.URL | b64enc }}' | base64 -d > '/tmp/url_{{ $t.Index }}.txt'
  wget -q -i '/tmp/url_{{ $t.Index }}.txt' -O '{{ $t.OutputPath }}'
  rm -f '/tmp/url_{{ $t.Index }}.txt'
else
  echo 'SKIP {{ $t.OutputPath }} (already exists)'
fi
{{- end }}
VERIFY_FAILED=0
{{- range $i, $t := $tasks }}
{{- if eq (mod $i 2) 1 }}
{{- $bin := index $tasks (sub $i 1) }}
HASH_LINE=$(awk -v path='{{ relpath $bin.URL $t.URL }}' '$2==path || $2=="./"path || $2=="*"path || $2=="*./"path {print; exit}' '{{ $t.OutputPath }}')
EXPECTED=""
ALGO=""
for word in $HASH_LINE; do
  case "$word" in
    *[!0-9a-fA-F]*) continue ;;
  esac
  WORD_LEN=${#word}
  if [ "$WORD_LEN" -eq 64 ]; then
    EXPECTED=$(echo "$word" | tr 'A-F' 'a-f')
    ALGO=SHA256
    break
  elif [ "$WORD_LEN" -eq 128 ]; then
    EXPECTED=$(echo "$word" | tr 'A-F' 'a-f')
    ALGO=SHA512
    break
  fi
done
if [ -z "$ALGO" ]; then
  echo 'ERROR: no valid hash found for {{ $bin.OutputPath }}' >&2
  rm -f '{{ $bin.OutputPath }}'
  VERIFY_FAILED=1
else
  if [ "$ALGO" = "SHA256" ]; then
    ACTUAL=$(sha256sum '{{ $bin.OutputPath }}' | awk '{print $1}')
  else
    ACTUAL=$(sha512sum '{{ $bin.OutputPath }}' | awk '{print $1}')
  fi
  echo "Expected ($ALGO): $EXPECTED"
  echo "Actual   ($ALGO): $ACTUAL"
  if [ "$EXPECTED" = "$ACTUAL" ]; then
    echo 'PASS: {{ $bin.OutputPath }}'
  else
    echo 'FAIL: {{ $bin.OutputPath }}' >&2
    rm -f '{{ $bin.OutputPath }}'
    VERIFY_FAILED=1
  fi
fi
{{- end }}
{{- end }}
if [ "$VERIFY_FAILED" -eq 1 ]; then
  exit 1
fi
{{- if .ISO }}
echo "--- Extracting from ISO ---"
MOUNT_DIR=$(mktemp -d)
trap 'umount "$MOUNT_DIR" 2>/dev/null; rmdir "$MOUNT_DIR" 2>/dev/null' EXIT
mount -o ro,loop '{{ .ISO.ISOPath }}' "$MOUNT_DIR" || { echo "ERROR: failed to mount ISO" >&2; exit 1; }
mkdir -p '{{ .ISO.KernelDstDir }}'
cp "$MOUNT_DIR"/'{{ .ISO.KernelSrc }}' '{{ .ISO.KernelDst }}'
mkdir -p '{{ .ISO.InitrdDstDir }}'
cp "$MOUNT_DIR"/'{{ .ISO.InitrdSrc }}' '{{ .ISO.InitrdDst }}'
umount "$MOUNT_DIR"
rmdir "$MOUNT_DIR"
trap - EXIT
echo 'Extracted kernel: {{ .ISO.KernelDst }}'
echo 'Extracted initrd: {{ .ISO.InitrdDst }}'
{{- end }}
{{- if .Firmware }}
echo "--- Building combined initrd with firmware ---"
if [ -f '{{ .Firmware.OutputPath }}' ]; then
  echo 'SKIP {{ .Firmware.OutputPath }} (already exists)'
else
  mkdir -p '{{ .Firmware.OutputDir }}'
  cat '{{ .Firmware.InitrdPath }}' '{{ .Firmware.FirmwarePath }}' > '{{ .Firmware.OutputPath }}'
  echo 'Combined initrd: {{ .Firmware.OutputPath }}'
fi
{{- end }}
echo "--- File sizes ---"
{{- range $i, $t := $tasks }}
{{- if eq (mod $i 2) 0 }}
du -h '{{ $t.OutputPath }}' 2>/dev/null || echo '{{ $t.OutputPath }}: not found'
{{- end }}
{{- end }}
{{- if .ISO }}
du -h '{{ .ISO.KernelDst }}' 2>/dev/null || echo '{{ .ISO.KernelDst }}: not found'
du -h '{{ .ISO.InitrdDst }}' 2>/dev/null || echo '{{ .ISO.InitrdDst }}: not found'
{{- end }}
{{- if .Firmware }}
du -h '{{ .Firmware.OutputPath }}' 2>/dev/null || echo '{{ .Firmware.OutputPath }}: not found'
{{- end }}
